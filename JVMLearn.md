#深入理解Java虚拟机 读书笔记

##两种异常

- StackOverflowError: 线程请求的<font color=red>栈深度</font>大于虚拟机所允许的最大空间
- OutOfMemoryError: 虚拟机在扩展栈时无法申请到足够的内存空间

但是，这两种异常存在着一些互相重叠的地方：当栈空间无法继续分配是，到底是内存太小，还是已使用的栈空间太大，其本质上只是对同一件事情的两种描述而已。

##String是final类型的，所以String不能被继承

##String.intern()：
　　**<font color=red>如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的String对象；否则，将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。</font>**

*注：“==” 比较的是两个对象的引用(内存地址)是否相同*

###采用new 创建的字符串对象，不会进入字符串常量池
```
        String a = "abc";
        String b = new String("abc");
        String c = "abc";
        System.out.println("a == b: " + (a == b));//输出为false
        System.out.println("b.intern() == a: " + (b.intern() == a));//输出为true
        System.out.println("a == c : " + (a == c));//输出为true
```
- 字符串"abc"已经在字符串常量池中，并有一个引用a。
- 而变量b是new出来的String，则b是一个新的引用，故有a == b 为false。
- 由于字符串常量池中已经有"abc"了，所以a.intern()返回的是字符串常量池中的该字符串的引用，所以会有b.intern() == a 为true。
- 引用c也指向字符串常量池中的"abc"，所以a == c 为true。

###字符串相加的时候，都是静态字符串的结果会添加到字符串常量池，如果其中包含变量，则不会进入字符串常量池
```
        String a = "abcd";
        String b = "ab" + "cd";
        String c = "ab";
        String d = c + "cd";
        String e = c + "cd";
        System.out.println("a == b : " + (a == b));//输出为true
        System.out.println("a == d : " + (a == d));//输出为false
        System.out.println("d == e : " + (d == e));//输出为false

        System.out.println(d.intern() == e);
```
- 字符串"abcd"已经在字符串常量池中，并有一个引用a。
- 引用b引用静态字符串"ab" + "cd"，则b所引用的对象也在字符串常量池中，故a == b 为true。
- 引用d是变量c+常量"cd"，包含了变量，则不会进入字符串常量池，而会有一个新的引用，故a == d 为false。
- 同理，e也已是一个新的引用，故有 d == e 为false。

　　这是今天在看《深入理解Java虚拟机》这本java经典读物，看到有关方法区和运行时常量池这块，才发现String还有这么多的坑，所以就自己实际写测试代码看了下，小小的总结下。String经常会在面试中问到，所以深入理解了还是很重要的。
　　
## 第3章 垃圾回收器与内存分配策略

垃圾回收Carbage Collection,GC

###怎么判断对象已死
####1. 引用计数算法
给对象中添加一个引用计数器，每当有一个地方引用它时，计数器就加1；当引用失效时，计数器就减1；任何时刻计数器为0的对象就是不可能再被使用的。

但是，主流的Java虚拟机里面没有选用引用计数算法来管理内存，其中最主要的原因是它很难解决对象之间相互循环引用的问题。


####2. 可达性分析算法
在主流的商用程序语言(Java,C#)的主流实现中，都是称通过可达性性分析(Reachability Analysis)来判定对象是否存活的。这个算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链相连(用图论的话来说，就是从GC Roots 到这个对象**不可达**)时，则证明此对象是不可用的。

Java语言中，可作为GC Roots的对象包括下面几种：

- 虚拟机栈(栈帧中的本地变量表)中引用的对象
- 方法区中静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈JNI(即一般说的Native方法)引用的对象

####四种引用

在JDK1.2之后，Java对引用的概念进行了扩充，将引用分为强引用(Strong Reference)、软引用(Soft Reference)、弱引用(Weak Reference)、虚引用(Phantom Reference)4种，这4种引用强度依次逐渐减弱。

- 强引用就是指在程序代码之中普遍存在的，类似`Object obj = new Object()`这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。
- 软引用是用来描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统将要发生**内存溢出**异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK1.2之后，提供了SoftReference 类来实现软引用。
- 弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象**只能生存到下一次垃圾收集发生之前**。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK1.2之后，提供了WeakReference类来实现弱引用。
- 虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时受到一个系统通知。在JDK1.2之后，提供了PhantomReference类来实现虚引用。

###3.3垃圾回收算法
####1. 标记-清除算法
####2. 复制算法
####3. 标记-整理算法
####4. 分代收集算法